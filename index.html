<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>BabyAGI: A Technical History</title>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500;600&family=EB+Garamond:ital,wght@0,400;0,500;0,600;1,400&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --bg: #f5f3ef;
  --bg-alt: #eae7e1;
  --text: #1a1a1a;
  --text-dim: #6b6560;
  --text-faint: #9b9590;
  --border: #d4cfc8;
  --border-light: #e6e2db;
  --mono: 'IBM Plex Mono', monospace;
  --serif: 'EB Garamond', Georgia, serif;
}

html { font-size: 16px; scroll-behavior: smooth; }

body {
  background: var(--bg);
  color: var(--text);
  font-family: var(--serif);
  line-height: 1.7;
  -webkit-font-smoothing: antialiased;
}

::selection { background: #1a1a1a; color: var(--bg); }

/* Layout */
.container { max-width: 820px; margin: 0 auto; padding: 0 2rem; }

/* Header */
header {
  padding: 6rem 0 4rem;
  border-bottom: 1px solid var(--border);
}
header h1 {
  font-family: var(--mono);
  font-size: 0.75rem;
  font-weight: 400;
  letter-spacing: 0.15em;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 1.5rem;
}
header .title {
  font-family: var(--serif);
  font-size: 2.8rem;
  font-weight: 500;
  line-height: 1.15;
  letter-spacing: -0.02em;
  margin-bottom: 1rem;
}
header .subtitle {
  font-size: 1.15rem;
  color: var(--text-dim);
  max-width: 600px;
  line-height: 1.6;
}
header .meta {
  margin-top: 2rem;
  font-family: var(--mono);
  font-size: 0.72rem;
  color: var(--text-faint);
  letter-spacing: 0.05em;
}

/* Navigation */
nav {
  position: sticky;
  top: 0;
  z-index: 100;
  background: var(--bg);
  border-bottom: 1px solid var(--border-light);
  padding: 0.75rem 0;
  margin-bottom: 1rem;
}
nav .container {
  display: flex;
  gap: 0;
  overflow-x: auto;
  scrollbar-width: none;
}
nav .container::-webkit-scrollbar { display: none; }
nav a {
  font-family: var(--mono);
  font-size: 0.65rem;
  text-decoration: none;
  color: var(--text-faint);
  white-space: nowrap;
  padding: 0.3rem 0.6rem;
  border-radius: 2px;
  transition: color 0.2s, background 0.2s;
  letter-spacing: 0.03em;
}
nav a:hover { color: var(--text); background: var(--bg-alt); }

/* Sections */
.version {
  padding: 4rem 0;
  border-bottom: 1px solid var(--border-light);
}
.version:last-of-type { border-bottom: none; }

.version-header {
  display: grid;
  grid-template-columns: 1fr auto;
  align-items: baseline;
  gap: 1rem;
  margin-bottom: 0.3rem;
}
.version-name {
  font-family: var(--serif);
  font-size: 1.9rem;
  font-weight: 500;
  letter-spacing: -0.01em;
}
.version-name::before {
  content: '+';
  font-family: var(--mono);
  font-size: 0.65rem;
  font-weight: 300;
  color: var(--border);
  margin-right: 0.5rem;
  vertical-align: middle;
  position: relative;
  top: -0.15rem;
}
.version-date {
  font-family: var(--mono);
  font-size: 0.75rem;
  color: var(--bg);
  background: var(--text);
  letter-spacing: 0.04em;
  font-weight: 400;
  padding: 0.25rem 0.5rem;
  border-radius: 2px;
  display: inline-block;
}
.version-loc {
  font-family: var(--mono);
  font-size: 0.68rem;
  color: var(--text-faint);
  margin-bottom: 1.8rem;
}

.version p {
  font-size: 1.05rem;
  margin-bottom: 1rem;
  color: var(--text);
}
.version p.dim { color: var(--text-dim); }

/* Code blocks */
pre {
  background: var(--bg-alt);
  border: 1px solid var(--border-light);
  padding: 1.2rem 1.5rem;
  margin: 1.5rem 0;
  overflow-x: auto;
  font-family: var(--mono);
  font-size: 0.78rem;
  line-height: 1.65;
  color: var(--text);
  border-radius: 2px;
}
code {
  font-family: var(--mono);
  font-size: 0.85em;
  background: var(--bg-alt);
  padding: 0.1em 0.35em;
  border-radius: 2px;
}
pre code { background: none; padding: 0; font-size: 1em; }

/* Architecture diagrams (ASCII) */
.arch {
  background: var(--bg-alt);
  border: 1px solid var(--border-light);
  padding: 1.5rem 2rem;
  margin: 1.5rem 0;
  font-family: var(--mono);
  font-size: 0.72rem;
  line-height: 1.5;
  white-space: pre;
  overflow-x: auto;
  color: var(--text-dim);
  border-radius: 2px;
}

/* Section labels */
.label {
  font-family: var(--mono);
  font-size: 0.68rem;
  font-weight: 500;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--text-faint);
  margin-bottom: 0.6rem;
  margin-top: 2rem;
}

/* Key insight callouts */
.insight {
  border-left: 3px solid #8b7355;
  padding: 1rem 1.2rem 1rem 1.4rem;
  margin: 1.5rem 0;
  font-style: italic;
  color: var(--text);
  font-size: 1rem;
  background: rgba(139, 115, 85, 0.06);
  border-radius: 0 4px 4px 0;
}

/* Stats grid */
.stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 1px;
  background: var(--border-light);
  border: 1px solid var(--border-light);
  margin: 1.5rem 0;
  border-radius: 2px;
}
.stat {
  background: var(--bg);
  padding: 1rem 1.2rem;
}
.stat-value {
  font-family: var(--mono);
  font-size: 1.3rem;
  font-weight: 500;
  letter-spacing: -0.02em;
}
.stat-label {
  font-family: var(--mono);
  font-size: 0.62rem;
  color: var(--text-faint);
  letter-spacing: 0.06em;
  text-transform: uppercase;
  margin-top: 0.2rem;
}

/* Diff-style additions */
.diff-add { color: #3a6b35; }
.diff-context { color: var(--text-dim); }

/* Timeline connector */
.timeline-gap {
  text-align: center;
  padding: 2rem 0;
  font-family: var(--mono);
  font-size: 0.7rem;
  color: var(--text-faint);
  letter-spacing: 0.1em;
}

/* Footer */
footer {
  padding: 3rem 0 4rem;
  border-top: 1px solid var(--border);
  margin-top: 2rem;
  font-family: var(--mono);
  font-size: 0.68rem;
  color: var(--text-faint);
  letter-spacing: 0.03em;
}

/* Comparison table — breaks out of container to full width */
.comparison-wrap {
  overflow-x: auto;
  margin: 1.5rem 0 2rem;
  border-top: 1px solid var(--border-light);
  border-bottom: 1px solid var(--border-light);
  width: 100vw;
  position: relative;
  left: 50%;
  transform: translateX(-50%);
}
.comparison-table {
  width: 100%;
  border-collapse: collapse;
  font-family: var(--mono);
  font-size: 0.68rem;
  line-height: 1.5;
}
.comparison-table th {
  text-align: left;
  padding: 0.7rem 1.2rem;
  font-weight: 500;
  letter-spacing: 0.04em;
  color: var(--text-dim);
  background: var(--bg-alt);
  border-bottom: 1px solid var(--border);
  white-space: nowrap;
  position: sticky;
  top: 0;
}
.comparison-table th:first-child {
  position: sticky;
  left: 0;
  z-index: 2;
  background: var(--bg-alt);
  padding-left: 1.2rem;
}
.comparison-table td {
  padding: 0.55rem 1.2rem;
  border-bottom: 1px solid var(--border-light);
  color: var(--text);
  vertical-align: top;
}
.comparison-table td:first-child {
  font-weight: 500;
  color: var(--text-dim);
  white-space: nowrap;
  background: var(--bg);
  position: sticky;
  left: 0;
  z-index: 1;
  padding-left: 1.2rem;
}
.comparison-table td:last-child,
.comparison-table th:last-child {
  padding-right: 1.2rem;
}
.comparison-table tbody tr:hover td { background: var(--bg-alt); }
.comparison-table tbody tr:hover td:first-child { background: var(--bg-alt); }
.comparison-table td.highlight {
  color: var(--text);
  font-weight: 500;
}
.comparison-table a {
  color: var(--text);
  text-decoration: none;
  border-bottom: 1px solid var(--border);
}
.comparison-table a:hover { border-color: var(--text); }

/* Summary section */
.summary {
  padding: 3rem 0 2rem;
  border-bottom: 1px solid var(--border-light);
}
.summary p {
  font-size: 1.05rem;
  margin-bottom: 1rem;
  color: var(--text);
  max-width: 700px;
}
.summary p.dim {
  color: var(--text-dim);
  font-size: 0.95rem;
}

/* Phase markers */
.phase-label {
  font-family: var(--mono);
  font-size: 0.58rem;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--text-faint);
  padding: 0.15rem 0.4rem;
  border: 1px solid var(--border-light);
  border-radius: 2px;
  display: inline-block;
  margin-bottom: 0.3rem;
}

/* (timeline visualization CSS removed — using comparison table instead) */

/* ─── Aside / sidebar section ─── */
.aside-section {
  background: #edeae4;
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  padding: 3rem 0;
  margin: 0.5rem 0;
}
.aside-section .version-name {
  font-size: 1.4rem;
}
.aside-section p {
  font-size: 1.02rem;
  margin-bottom: 1rem;
  color: var(--text);
}
.aside-section p.dim { color: var(--text-dim); }
.aside-section .label { margin-top: 1.8rem; }
.aside-section code {
  background: #d4cfc8;
}
.aside-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 1.5rem;
  margin: 1.5rem 0;
}
.aside-card {
  border: 1px solid var(--border);
  border-radius: 2px;
  padding: 1.2rem;
  background: var(--bg);
}
.aside-card-title {
  font-family: var(--mono);
  font-size: 0.72rem;
  font-weight: 500;
  color: var(--text);
  margin-bottom: 0.2rem;
}
.aside-card-date {
  font-family: var(--mono);
  font-size: 0.62rem;
  color: var(--bg);
  background: var(--text);
  margin-bottom: 0.8rem;
  font-weight: 400;
  padding: 0.25rem 0.5rem;
  border-radius: 2px;
  display: inline-block;
}
.aside-card p {
  font-size: 0.92rem;
  margin-bottom: 0.5rem;
  line-height: 1.6;
}
.aside-card code {
  font-size: 0.8em;
}
@media (max-width: 640px) {
  .aside-grid { grid-template-columns: 1fr; }
}

/* ─── Complexity heatmap ─── */
.heatmap-wrap {
  margin: 1.5rem 0 2rem;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}
.heatmap {
  display: grid;
  grid-template-columns: auto repeat(9, 1fr);
  gap: 2px;
  font-family: var(--mono);
  font-size: 0.6rem;
  max-width: 700px;
  min-width: 520px;
}
.heatmap-header {
  text-align: center;
  color: var(--text-dim);
  font-weight: 500;
  padding: 0.4rem 0.3rem;
  font-size: 0.58rem;
}
.heatmap-row-label {
  color: var(--text-dim);
  padding: 0.4rem 0.6rem 0.4rem 0;
  text-align: right;
  white-space: nowrap;
  font-size: 0.58rem;
}
.heatmap-cell {
  text-align: center;
  padding: 0.4rem 0.2rem;
  border-radius: 2px;
  color: var(--text-faint);
  font-size: 0.56rem;
}
.heatmap-cell.l0 { background: var(--bg); }
.heatmap-cell.l1 { background: #e8e4dd; color: var(--text-dim); }
.heatmap-cell.l2 { background: #d4cfc8; color: var(--text-dim); }
.heatmap-cell.l3 { background: #b8b0a5; color: var(--bg); }
.heatmap-cell.l4 { background: #8a8078; color: var(--bg); }
.heatmap-cell.l5 { background: #5a524a; color: var(--bg); }
.heatmap-cell.l6 { background: #1a1a1a; color: var(--bg); font-weight: 500; }

/* ─── Code anatomy bar chart ─── */
.anatomy-chart {
  margin: 1.5rem 0 2rem;
  max-width: 700px;
}
.anatomy-row {
  display: grid;
  grid-template-columns: 85px 1fr 45px;
  align-items: center;
  margin-bottom: 3px;
  font-family: var(--mono);
  font-size: 0.6rem;
}
.anatomy-label {
  color: var(--text-dim);
  text-align: right;
  padding-right: 0.8rem;
  font-size: 0.58rem;
}
.anatomy-bar-wrap {
  height: 18px;
  display: flex;
  gap: 1px;
}
.anatomy-segment {
  height: 100%;
  border-radius: 1px;
  transition: opacity 0.2s;
}
.anatomy-segment:hover { opacity: 0.8; }
.seg-core { background: #1a1a1a; }
.seg-tools { background: #5a524a; }
.seg-memory { background: #8a8078; }
.seg-io { background: #b8b0a5; }
.seg-infra { background: #d4cfc8; }
.anatomy-total {
  color: var(--text-faint);
  padding-left: 0.5rem;
  font-size: 0.56rem;
}
.anatomy-legend {
  display: flex;
  gap: 1.2rem;
  margin-top: 0.8rem;
  font-family: var(--mono);
  font-size: 0.55rem;
  color: var(--text-dim);
  flex-wrap: wrap;
}
.anatomy-legend-item {
  display: flex;
  align-items: center;
  gap: 4px;
}
.anatomy-legend-swatch {
  width: 10px;
  height: 10px;
  border-radius: 1px;
  flex-shrink: 0;
}

/* ─── Lessons ─── */
.lessons-grid {
  display: flex;
  flex-direction: column;
  gap: 0;
  margin: 1.5rem 0 2rem;
}
.lesson-card {
  padding: 0.8rem 0;
  border-bottom: 1px solid var(--border-light);
  position: relative;
  display: grid;
  grid-template-columns: 2rem 1fr;
  gap: 0;
  align-items: baseline;
}
.lesson-card:first-child { border-top: 1px solid var(--border-light); }
.lesson-card::before {
  content: attr(data-num);
  font-family: var(--mono);
  font-size: 0.55rem;
  font-weight: 400;
  color: var(--text-faint);
  letter-spacing: 0.04em;
  padding-top: 0.2rem;
}
.lesson-title {
  font-family: var(--serif);
  font-size: 1.05rem;
  font-weight: 600;
  color: var(--text);
  display: inline;
}
.lesson-card p {
  font-size: 1.02rem;
  margin-bottom: 0;
  color: var(--text-dim);
  line-height: 1.65;
  grid-column: 2;
  display: inline;
}
.lesson-card .lesson-body { grid-column: 2; }

/* ─── Mobile scroll hint ─── */
.scroll-hint {
  display: none;
  font-family: var(--mono);
  font-size: 0.58rem;
  color: var(--text-faint);
  margin-left: 0.5rem;
  font-weight: 300;
}
@media (max-width: 640px) {
  .scroll-hint { display: inline; }
}

/* ─── Architectural transitions styled list ─── */
.transitions-list {
  margin: 1.5rem 0 2rem;
}
.transition-item {
  display: grid;
  grid-template-columns: 110px 1fr;
  gap: 0;
  padding: 1rem 0;
  border-bottom: 1px solid var(--border-light);
}
.transition-item:first-child { border-top: 1px solid var(--border-light); }
.transition-label {
  font-family: var(--mono);
  font-size: 0.65rem;
  font-weight: 500;
  color: var(--text-dim);
  padding-top: 0.15rem;
  letter-spacing: 0.03em;
}
.transition-stages {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 0;
  font-size: 0.88rem;
  line-height: 1.6;
  color: var(--text);
}
.transition-stages .stage {
  white-space: nowrap;
}
.transition-stages .arrow {
  color: var(--text-faint);
  margin: 0 0.4rem;
  font-family: var(--mono);
  font-size: 0.7rem;
}

/* ─── Active nav state ─── */
nav a.active {
  color: var(--text);
  border-bottom: 1.5px solid var(--text);
  padding-bottom: 1px;
}

/* ─── Accent decorations (CSS only) ─── */
.accent-line {
  width: 40px;
  height: 2px;
  background: var(--border);
  margin: 2rem 0;
}
.accent-line.center { margin-left: auto; margin-right: auto; }

/* ─── Impact section ─── */
.impact-section {
  padding: 3.5rem 0 3rem;
  margin-top: 1rem;
}
.impact-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 2rem;
  margin: 2rem 0;
}
.impact-stat {
  text-align: center;
  padding: 1.5rem 0;
}
.impact-num {
  font-family: var(--serif);
  font-size: 2.8rem;
  font-weight: 600;
  color: var(--text);
  line-height: 1;
  margin-bottom: 0.4rem;
}
.impact-desc {
  font-family: var(--mono);
  font-size: 0.62rem;
  color: var(--text-dim);
  letter-spacing: 0.04em;
}
@media (max-width: 640px) {
  .impact-grid { grid-template-columns: 1fr; gap: 1rem; }
}

/* ─── Source button ─── */
.source-btn {
  font-family: var(--mono);
  font-size: inherit;
  color: var(--text-faint);
  background: none;
  border: 1px solid var(--border-light);
  padding: 0.1rem 0.45rem 0.14rem;
  border-radius: 2px;
  cursor: pointer;
  letter-spacing: 0.04em;
  transition: all 0.2s;
  margin-left: 0.6rem;
  line-height: 1;
}
.source-btn:hover {
  color: var(--text);
  border-color: var(--border);
  background: var(--bg-alt);
}

/* ─── Source modal ─── */
.source-overlay {
  position: fixed;
  inset: 0;
  background: rgba(26, 26, 26, 0.3);
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.25s, visibility 0.25s;
  backdrop-filter: blur(2px);
  -webkit-backdrop-filter: blur(2px);
}
.source-overlay.active {
  opacity: 1;
  visibility: visible;
}
.source-modal {
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 3px;
  width: 92vw;
  max-width: 960px;
  height: 80vh;
  max-height: 700px;
  display: grid;
  grid-template-rows: auto 1fr;
  overflow: hidden;
  box-shadow: 0 12px 48px rgba(0,0,0,0.1), 0 2px 8px rgba(0,0,0,0.06);
  transform: translateY(8px) scale(0.99);
  transition: transform 0.25s ease-out;
}
.source-overlay.active .source-modal {
  transform: translateY(0) scale(1);
}
.source-modal-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.7rem 1.2rem;
  border-bottom: 1px solid var(--border-light);
  font-family: var(--mono);
  font-size: 0.72rem;
  gap: 0.8rem;
}
.source-modal-left {
  display: flex;
  align-items: center;
  gap: 0.8rem;
  min-width: 0;
}
.source-modal-title {
  font-weight: 500;
  color: var(--text);
  letter-spacing: 0.02em;
  white-space: nowrap;
}
.source-modal-link {
  color: var(--text-faint);
  text-decoration: none;
  font-size: 0.62rem;
  border-bottom: 1px solid var(--border-light);
  transition: color 0.2s, border-color 0.2s;
  white-space: nowrap;
}
.source-modal-link:hover {
  color: var(--text);
  border-color: var(--text-dim);
}
.source-modal-close {
  background: none;
  border: none;
  font-family: var(--mono);
  font-size: 0.85rem;
  color: var(--text-faint);
  cursor: pointer;
  padding: 0.2rem 0.35rem;
  line-height: 1;
  transition: color 0.2s;
  flex-shrink: 0;
}
.source-modal-close:hover { color: var(--text); }
.source-modal-body {
  display: grid;
  grid-template-columns: 230px 1fr;
  overflow: hidden;
}
.source-tree {
  border-right: 1px solid var(--border-light);
  overflow-y: auto;
  padding: 0.5rem 0;
  font-family: var(--mono);
  font-size: 0.66rem;
  scrollbar-width: thin;
  scrollbar-color: var(--border-light) transparent;
}
.source-tree-item {
  display: block;
  width: 100%;
  text-align: left;
  background: none;
  border: none;
  font-family: var(--mono);
  font-size: 0.64rem;
  color: var(--text-dim);
  padding: 0.18rem 1rem;
  cursor: pointer;
  transition: background 0.12s, color 0.12s;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  line-height: 1.6;
}
.source-tree-item:hover {
  background: var(--bg-alt);
  color: var(--text);
}
.source-tree-item.active {
  background: var(--bg-alt);
  color: var(--text);
  font-weight: 500;
}
.source-tree-item.is-folder {
  color: var(--text);
  font-weight: 500;
}
.source-tree-item .folder-arrow {
  font-size: 0.5rem;
  margin-right: 3px;
  display: inline-block;
  transition: transform 0.15s;
}
.source-tree-item.is-folder.closed .folder-arrow {
  transform: rotate(0deg);
}
.source-tree-item.is-folder.open .folder-arrow {
  transform: rotate(90deg);
}
.source-code-wrap {
  display: grid;
  grid-template-rows: auto 1fr;
  overflow: hidden;
  background: var(--bg-alt);
}
.source-code-path {
  font-family: var(--mono);
  font-size: 0.6rem;
  color: var(--text-faint);
  padding: 0.4rem 1.2rem;
  border-bottom: 1px solid var(--border-light);
  letter-spacing: 0.03em;
  background: var(--bg);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.source-code {
  overflow: auto;
  scrollbar-width: thin;
  scrollbar-color: var(--border) var(--bg-alt);
}
.source-code-inner {
  padding: 0.6rem 0;
  font-family: var(--mono);
  font-size: 0.72rem;
  line-height: 1.65;
  white-space: pre;
  color: var(--text);
  tab-size: 4;
}
.source-line {
  display: flex;
  padding: 0 1.2rem 0 0;
}
.source-line:hover {
  background: rgba(0,0,0,0.025);
}
.source-line-num {
  flex-shrink: 0;
  width: 3.5rem;
  text-align: right;
  padding-right: 1rem;
  color: var(--border);
  user-select: none;
  font-size: 0.62rem;
}
.source-line-content {
  flex: 1;
  min-width: 0;
}
.source-placeholder {
  display: flex;
  align-items: center;
  justify-content: center;
  height: 100%;
  font-family: var(--mono);
  font-size: 0.65rem;
  color: var(--text-faint);
  letter-spacing: 0.04em;
}
.source-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 2rem;
  font-family: var(--mono);
  font-size: 0.65rem;
  color: var(--text-faint);
  letter-spacing: 0.04em;
}
@keyframes source-pulse {
  0%, 100% { opacity: 0.4; }
  50% { opacity: 1; }
}
.source-loading-dots {
  animation: source-pulse 1.2s ease-in-out infinite;
}

/* Responsive */
@media (max-width: 640px) {
  header .title { font-size: 2rem; }
  .version-name { font-size: 1.5rem; }
  .container { padding: 0 1.2rem; }
  .version { padding: 3rem 0; }
  header { padding: 4rem 0 3rem; }
  .version-header { grid-template-columns: 1fr; }
  .aside-grid { grid-template-columns: 1fr; }
  .transition-item { grid-template-columns: 1fr; gap: 0.3rem; }
  /* Tables: keep in container on mobile */
  .comparison-wrap {
    width: 100% !important;
    left: 0 !important;
    transform: none !important;
  }
  .source-modal {
    width: 97vw;
    height: 88vh;
    max-height: none;
  }
  .source-modal-body {
    grid-template-columns: 1fr;
  }
  .source-tree {
    border-right: none;
    border-bottom: 1px solid var(--border-light);
    max-height: 35vh;
  }
  .source-modal-link { display: none; }
}
</style>
</head>
<body>

<header>
<div class="container">
  <h1>Technical History</h1>
  <div class="title">BabyAGI</div>
  <div class="subtitle">One person's three-year journey exploring autonomous agents through code. Nine versions, nine different bets on how to build an AI that can act on its own.</div>
  <div class="meta">April 2023 – February 2026 &nbsp;·&nbsp; Yohei Nakajima &nbsp;·&nbsp; Analysis from source code</div>
  <div class="accent-line" style="margin-top: 2.5rem; margin-bottom: 0;"></div>
</div>
</header>

<nav>
<div class="container">
  <a href="#original">BabyAGI</a>
  <a href="#bee">Bee</a>
  <a href="#cat">Cat</a>
  <a href="#deer">Deer</a>
  <a href="#elf">Elf</a>
  <a href="#fox">Fox</a>
  <a href="#graph-projects">Graphs</a>
  <a href="#v2">v2</a>
  <a href="#v2o">2o</a>
  <a href="#v3">v3</a>
  <a href="#evolution">Evolution</a>
  <a href="#timeline">Timeline</a>
</div>
</nav>

<main>
<div class="container">

<!-- ═══════════════════════════ SUMMARY ═══════════════════════════ -->
<section class="summary" id="summary">
<div class="label">Overview</div>

<p>BabyAGI started as a weekend experiment: 105 lines of Python that looped forever, chaining LLM calls to execute tasks. Over three years and nine iterations, it became a testing ground for every major idea in autonomous agent design — task graphs, parallel execution, plugin systems, self-extending tools, persistent memory, multi-channel I/O. Each version asked a different question about what it takes to build an agent that can actually do things on its own.</p>

<p class="dim">The journey mirrors the broader evolution of the agent ecosystem. The <strong>classic era</strong> (Apr–Sep 2023) explored task list architectures during the initial burst of excitement after GPT-4. The <strong>framework era</strong> (Sep–Oct 2024) reconsidered the problem from first principles as tool-calling APIs matured. The <strong>assistant era</strong> (Feb 2026) confronted everything the earlier versions ignored: error recovery, context management, concurrency, and real-world I/O — building not just an agent but an autonomous assistant.</p>

<div class="label">Comparison <span class="scroll-hint">scroll →</span></div>

<div class="comparison-wrap">
<table class="comparison-table">
<thead>
<tr>
  <th></th>
  <th><a href="#original">BabyAGI</a></th>
  <th><a href="#bee">Bee</a></th>
  <th><a href="#cat">Cat</a></th>
  <th><a href="#deer">Deer</a></th>
  <th><a href="#elf">Elf</a></th>
  <th><a href="#fox">Fox</a></th>
  <th><a href="#v2">v2</a></th>
  <th><a href="#v2o">2o</a></th>
  <th><a href="#v3">v3</a></th>
</tr>
</thead>
<tbody>
<tr>
  <td>Date</td>
  <td>Apr '23</td>
  <td>Apr '23</td>
  <td>May '23</td>
  <td>Jun '23</td>
  <td>Jul '23</td>
  <td>Sep '23</td>
  <td>Sep '24</td>
  <td>Oct '24</td>
  <td>Feb '26</td>
</tr>
<tr>
  <td>Lines</td>
  <td>105</td>
  <td>300</td>
  <td>320</td>
  <td>354</td>
  <td>887</td>
  <td>2,299</td>
  <td>5,962</td>
  <td class="highlight">174</td>
  <td class="highlight">33,506</td>
</tr>
<tr>
  <td>Files</td>
  <td>1</td>
  <td>1</td>
  <td>1</td>
  <td>1</td>
  <td>11</td>
  <td>25+</td>
  <td>40+</td>
  <td>1</td>
  <td>70+</td>
</tr>
<tr>
  <td>Model</td>
  <td>davinci-003</td>
  <td>GPT-4</td>
  <td>GPT-4 + 3.5</td>
  <td>GPT-3.5</td>
  <td>GPT-3.5</td>
  <td>GPT-3.5-16k</td>
  <td>any</td>
  <td>any (litellm)</td>
  <td>any (litellm)</td>
</tr>
<tr>
  <td>Planning</td>
  <td>per-loop</td>
  <td>dynamic replan</td>
  <td>upfront</td>
  <td>upfront</td>
  <td>upfront + reflect</td>
  <td>upfront + reflect</td>
  <td>—</td>
  <td>implicit (LLM)</td>
  <td>implicit (LLM)</td>
</tr>
<tr>
  <td>Execution</td>
  <td>sequential</td>
  <td>sequential</td>
  <td>sequential</td>
  <td class="highlight">parallel</td>
  <td>parallel</td>
  <td>parallel</td>
  <td>sequential</td>
  <td>sequential</td>
  <td class="highlight">async + pool</td>
</tr>
<tr>
  <td>Task deps</td>
  <td>none</td>
  <td>single</td>
  <td class="highlight">multi</td>
  <td>multi</td>
  <td>multi</td>
  <td>multi</td>
  <td>fn graph</td>
  <td>none</td>
  <td>objective tree</td>
</tr>
<tr>
  <td>Termination</td>
  <td>never</td>
  <td>all complete</td>
  <td>all complete</td>
  <td>all complete</td>
  <td>all complete</td>
  <td>all complete</td>
  <td>manual</td>
  <td>tool signal</td>
  <td>end_turn</td>
</tr>
<tr>
  <td>Memory</td>
  <td>Pinecone</td>
  <td>session str</td>
  <td>dep chain</td>
  <td>dep chain</td>
  <td>embeddings</td>
  <td>ndjson + summary</td>
  <td>exec logs</td>
  <td>messages[]</td>
  <td class="highlight">SQLite + KG</td>
</tr>
<tr>
  <td>Tools</td>
  <td>0</td>
  <td>3</td>
  <td>3</td>
  <td>4</td>
  <td>7</td>
  <td>15+</td>
  <td>fn packs</td>
  <td class="highlight">self-creating</td>
  <td class="highlight">self-creating + persist</td>
</tr>
<tr>
  <td>Extensibility</td>
  <td>edit source</td>
  <td>edit source</td>
  <td>edit source</td>
  <td>edit source</td>
  <td class="highlight">skill plugins</td>
  <td>skill plugins</td>
  <td class="highlight">fn registry</td>
  <td>runtime exec()</td>
  <td>register + DB</td>
</tr>
<tr>
  <td>I/O</td>
  <td>CLI print</td>
  <td>CLI print</td>
  <td>CLI print</td>
  <td>CLI + file</td>
  <td>CLI + file</td>
  <td class="highlight">Flask web UI</td>
  <td>Flask dashboard</td>
  <td>CLI</td>
  <td class="highlight">multi-channel</td>
</tr>
<tr>
  <td>Concurrency</td>
  <td>—</td>
  <td>—</td>
  <td>—</td>
  <td>threads</td>
  <td>threads</td>
  <td>threads</td>
  <td>—</td>
  <td>—</td>
  <td class="highlight">async + semaphore</td>
</tr>
<tr>
  <td>Error handling</td>
  <td>—</td>
  <td>try/except</td>
  <td>try/except</td>
  <td>try/except</td>
  <td>try/except</td>
  <td>try/except</td>
  <td>logged</td>
  <td>try/except</td>
  <td class="highlight">retry + backoff + repair</td>
</tr>
<tr>
  <td>Key insight</td>
  <td>LLMs can chain tasks</td>
  <td>tasks need structure</td>
  <td>plan upfront</td>
  <td>parallelize DAG</td>
  <td>plugin architecture</td>
  <td>chat + reflection</td>
  <td>functions as atoms</td>
  <td>LLM is the planner</td>
  <td>autonomous assistant</td>
</tr>
</tbody>
</table>
</div>

<p class="dim">Each column links to the detailed analysis below. Highlighted cells mark the first appearance of a significant capability.</p>

</section>

<!-- ═══════════════════════════════════════════════════════════════ -->
<section class="version" id="original">
<div class="version-header">
  <div class="version-name">BabyAGI</div>
  <div class="version-date">April 4, 2023</div>
</div>
<div class="version-loc">105 lines · single file · Python <button class="source-btn" data-repo="yoheinakajima/babyagi_og" data-name="BabyAGI" data-branch="main">source ↗</button></div>

<p>The original BabyAGI is a deceptively simple infinite loop: execute a task, store the result, create new tasks, reprioritize, repeat. The entire system is three LLM calls chained inside a <code>while True</code>.</p>

<div class="label">Architecture</div>
<div class="arch">
┌─────────────────────────────────────────────────────┐
│                   while True:                       │
│                                                     │
│   task_list (deque) ──► execution_agent()            │
│         ▲                      │                    │
│         │                      ▼                    │
│   prioritization_agent()   result ──► Pinecone      │
│         ▲                      │      (embeddings)  │
│         │                      ▼                    │
│         └──── task_creation_agent()                  │
└─────────────────────────────────────────────────────┘</div>

<div class="label">Core Loop</div>
<pre><code><span class="diff-context"># The three-agent loop — entire system logic</span>
result = execution_agent(OBJECTIVE, task["task_name"])

<span class="diff-context"># Store in Pinecone with ada-002 embeddings</span>
index.upsert([(result_id, get_ada_embedding(vector),
  {"task": task['task_name'], "result": result})])

<span class="diff-context"># Generate new tasks from result</span>
new_tasks = task_creation_agent(OBJECTIVE, enriched_result,
  task["task_name"], [t["task_name"] for t in task_list])

<span class="diff-context"># Reprioritize everything</span>
prioritization_agent(this_task_id)</code></pre>

<div class="label">Key Decisions</div>
<p>Uses <code>text-davinci-003</code> (completion API, not chat). Pinecone for vector memory via <code>text-embedding-ada-002</code>. Task list is a Python <code>deque</code>. The <code>context_agent</code> retrieves the top-5 nearest results from Pinecone by cosine similarity but its output is never actually passed to the execution prompt — a telling sign this was a proof of concept.</p>

<div class="insight">The loop never terminates. There is no completion condition. This was the point: demonstrate that an LLM could autonomously generate and execute an unbounded task chain. Everything that followed was about adding structure to this unbounded loop.</div>

<div class="stats">
  <div class="stat"><div class="stat-value">3</div><div class="stat-label">LLM agents</div></div>
  <div class="stat"><div class="stat-value">0</div><div class="stat-label">tools</div></div>
  <div class="stat"><div class="stat-value">∞</div><div class="stat-label">loop</div></div>
  <div class="stat"><div class="stat-value">davinci-003</div><div class="stat-label">model</div></div>
</div>
</section>

<!-- ═══════════════════════════════════════════════════════════════ -->
<section class="version" id="bee">
<div class="version-header">
  <div class="version-name">BabyBeeAGI</div>
  <div class="version-date">April 30, 2023</div>
</div>
<div class="version-loc">300 lines · single file · Python <button class="source-btn" data-repo="yoheinakajima/babybeeagi" data-name="BabyBeeAGI" data-branch="main">source ↗</button></div>

<p>BabyBeeAGI introduces two foundational concepts: <strong>task dependencies</strong> and <strong>tools</strong>. Tasks are no longer a flat queue — each task carries a <code>dependent_task_id</code>, a <code>tool</code> specifier, and a <code>status</code>. Pinecone is dropped entirely; context is managed through a <code>session_summary</code>.</p>

<div class="label">Architecture</div>
<div class="arch">
task_list = [
  { id, task, tool, dependent_task_id,
    status, result, result_summary }
]

Tools: text-completion | web-search | web-scrape

New agents:
  task_manager_agent()   ← replaces creation + prioritization
  summarizer_agent()     ← per-task result compression
  overview_agent()       ← rolling session summary</div>

<div class="label">What Changed</div>
<p>The single <code>task_creation_agent</code> becomes a <code>task_manager_agent</code> that both creates and reprioritizes tasks — and it uses GPT-4 (chat API, not completion). Tasks now have explicit tool routing:</p>

<pre><code>if task["tool"] == "text-completion":
    result = text_completion_tool(task_prompt)
elif task["tool"] == "web-search":
    result = web_search_tool(task_prompt)
elif task["tool"] == "web-scrape":
    result = web_scrape_tool(str(task['task']))</code></pre>

<p>The task manager receives the entire task list (minus results, to fit context) and outputs a new JSON task list. Tasks are capped at 7 items. The loop now terminates when all tasks have <code>status: "complete"</code>.</p>

<div class="insight">The shift from "infinite loop with reprioritization" to "finite task graph with dependencies" is the first major architectural lesson. BabyBeeAGI answers the question: how do you make an autonomous agent stop?</div>

<div class="stats">
  <div class="stat"><div class="stat-value">4</div><div class="stat-label">LLM agents</div></div>
  <div class="stat"><div class="stat-value">3</div><div class="stat-label">tools</div></div>
  <div class="stat"><div class="stat-value">7</div><div class="stat-label">max tasks</div></div>
  <div class="stat"><div class="stat-value">GPT-4</div><div class="stat-label">model</div></div>
</div>
</section>

<!-- ═══════════════════════════════════════════════════════════════ -->
<section class="version" id="cat">
<div class="version-header">
  <div class="version-name">BabyCatAGI</div>
  <div class="version-date">May 13, 2023</div>
</div>
<div class="version-loc">320 lines · single file · Python <button class="source-btn" data-repo="yoheinakajima/babycatagi" data-name="BabyCatAGI" data-branch="main">source ↗</button></div>

<p>BabyCatAGI refactors BabyBeeAGI in two important ways. First, task creation is extracted into its own dedicated <code>task_creation_agent</code> that runs once at startup to produce the entire task plan upfront. Second, <code>dependent_task_id</code> becomes <code>dependent_task_ids</code> (plural) — tasks can now depend on multiple predecessors.</p>

<div class="label">Key Structural Change</div>
<pre><code><span class="diff-context"># BabyBeeAGI: single dependency</span>
"dependent_task_id": 2

<span class="diff-add"># BabyCatAGI: multiple dependencies</span>
<span class="diff-add">"dependent_task_ids": [1, 3, 4]</span></code></pre>

<p>The web search tool now automatically scrapes and extracts from each result URL. The extraction uses chunked processing with overlap — a primitive RAG pattern:</p>

<pre><code>chunk_size = 3000
overlap = 500
for i in range(0, len(large_string), chunk_size - overlap):
    chunk = large_string[i:i + chunk_size]
    # LLM extracts relevant info, appends to notes</code></pre>

<p>The session summary agent is removed. Context flows through task outputs via dependency chains. The task manager agent is also removed — the plan is fixed at creation time.</p>

<div class="insight">The move from dynamic replanning to a fixed upfront plan is a deliberate simplification. The dynamic task manager in BabyBeeAGI was unstable — it could produce malformed JSON, reorder completed tasks, or create loops. BabyCatAGI trades flexibility for reliability.</div>
</section>

<!-- ═══════════════════════════════════════════════════════════════ -->
<section class="version" id="deer">
<div class="version-header">
  <div class="version-name">BabyDeerAGI</div>
  <div class="version-date">June 6, 2023</div>
</div>
<div class="version-loc">354 lines · single file · Python <button class="source-btn" data-repo="yoheinakajima/babydeeragi" data-name="BabyDeerAGI" data-branch="main">source ↗</button></div>

<p>BabyDeerAGI's contribution is <strong>parallel execution</strong>. Tasks that have no mutual dependencies can now run concurrently using <code>ThreadPoolExecutor</code>.</p>

<div class="label">Parallel Execution</div>
<pre><code>from concurrent.futures import ThreadPoolExecutor

with ThreadPoolExecutor() as executor:
    while True:
        for task in task_list:
            if task["status"] == "incomplete" \
               and task_ready_to_run(task, task_list):
                future = executor.submit(
                    execute_task, task, task_list, OBJECTIVE)
                task["status"] = "running"</code></pre>

<p>New additions: a <code>user-input</code> tool for interactive queries (human-in-the-loop), task creation downgraded from GPT-4 to GPT-3.5-turbo (cost optimization), and a smarter web search that uses dependent task outputs to refine search queries:</p>

<pre><code>query = text_completion_tool(
    "Generate a Google search query based on the following task: "
    + query + ". " + dependent_task + "\nSearch Query:")</code></pre>

<p>Results are saved to timestamped files. The session summary is replaced by a concatenated output log.</p>

<div class="insight">Parallel execution is the natural next step once you have a dependency DAG. If tasks A and B both depend only on task 0, they can run simultaneously. This pattern — DAG-based parallel execution — becomes the standard for all subsequent versions.</div>
</section>

<!-- ═══════════════════════════════════════════════════════════════ -->
<section class="version" id="elf">
<div class="version-header">
  <div class="version-name">BabyElfAGI</div>
  <div class="version-date">July 10, 2023</div>
</div>
<div class="version-loc">887 lines · 11 files · Python <button class="source-btn" data-repo="yoheinakajima/babyagi" data-name="BabyElfAGI" data-branch="babyelfagi">source ↗</button></div>

<p>BabyElfAGI is the first multi-file architecture. The monolithic script splits into a <code>SkillRegistry</code>, a <code>TaskRegistry</code>, and individual skill modules. This is the birth of the <strong>plugin system</strong>.</p>

<div class="label">Architecture</div>
<div class="arch">
BabyElfAGI/
├── main.py                   ← orchestrator
├── skills/
│   ├── skill.py              ← abstract base class
│   ├── skill_registry.py     ← dynamic loader
│   ├── text_completion.py    ← skill implementation
│   ├── web_search.py
│   ├── code_reader.py
│   ├── skill_saver.py        ← meta: saves new skills
│   └── objective_saver.py
└── tasks/
    ├── task_registry.py      ← task + example matching
    └── example_objectives/   ← few-shot examples as JSON</div>

<div class="label">Skill Base Class</div>
<pre><code>class Skill:
    name = 'base skill'
    description = 'This is the base skill.'
    api_keys_required = []

    def __init__(self, api_keys):
        missing_keys = self.check_required_keys(api_keys)
        self.valid = not missing_keys

    def execute(self, params, dependent_task_outputs, objective):
        raise NotImplementedError</code></pre>

<p>Skills are discovered at runtime via filesystem scan and <code>importlib</code>. The registry filters by available API keys — skills with missing keys are silently skipped.</p>

<p>Task creation now uses <strong>few-shot example matching</strong>: example objective/tasklist pairs are stored as JSON files, and the most relevant example is selected using cosine similarity on ada-002 embeddings. An experimental <strong>reflection step</strong> can modify the task list after each execution.</p>

<div class="insight">The Skill base class with <code>api_keys_required</code> validation and dynamic discovery via <code>importlib</code> is a pattern that persists through every subsequent version. This is where BabyAGI becomes extensible rather than just editable.</div>
</section>

<!-- ═══════════════════════════════════════════════════════════════ -->
<section class="version" id="fox">
<div class="version-header">
  <div class="version-name">BabyFoxAGI</div>
  <div class="version-date">September 1, 2023</div>
</div>
<div class="version-loc">~2,300 lines · 25+ files · Python + Flask <button class="source-btn" data-repo="yoheinakajima/babyfoxagi" data-name="BabyFoxAGI" data-branch="main">source ↗</button></div>

<p>BabyFoxAGI adds a <strong>web UI and chat interface</strong>, powered by Flask. The agent is no longer a batch script — it's an interactive application. A user sends a message, and the system routes it to one of three paths: direct chat response, single skill execution, or full task list generation.</p>

<div class="label">Routing via Function Calling</div>
<pre><code><span class="diff-context"># GPT determines the path using OpenAI function calling</span>
functions=[{
    "name": "determine_response_type",
    "parameters": {
        "properties": {
            "path": {
                "enum": ["ChatCompletion", "Skill", "TaskList"]
            },
            "skill_used": { ... },
            "objective": { ... },
            "message_to_user": { ... }
        }
    }
}]</code></pre>

<p>Backgrounds tasks execute in threads. A <code>forever_cache.ndjson</code> file stores the full conversation history. A rolling summary is maintained by combining the latest 20 messages with a running overall summary — a two-tier memory system. Skills expand significantly: <code>image_generation</code>, <code>play_music</code>, <code>game_generation</code>, <code>startup_analysis</code>, <code>airtable_search</code>, <code>google_jobs_api_search</code>, and <code>drawing</code>.</p>

<p>The task registry adds <strong>objective reflection</strong>: before creating a task list, the system reflects on the objective to generate "helpful notes" that guide the task creation agent. After execution, it reflects on both the result (self-analysis) and the task list (generating improved versions saved as new example objectives).</p>

<div class="label">Self-Improvement Loop</div>
<div class="arch">
objective ──► reflect_on_objective() ──► create_tasklist()
                                              │
                                              ▼
                                         execute tasks
                                              │
                                              ▼
              reflect_on_final() ◄────── task outputs
                    │
                    ├──► improved_tasklist.json  (saved)
                    └──► skill gap analysis      (logged)</div>

<div class="insight">BabyFoxAGI introduces three patterns that define modern agent design: routing between response types (chat vs. action), persistent conversation memory, and self-improvement via reflection. The <code>reflect_skills()</code> method analyzes whether the available skills were sufficient — a proto-form of the self-extending agent that arrives in v2o and v3.</div>
</section>

<!-- ═══════════════════════════════════════════════════════════════ -->
<!-- ═══════════════════════ GRAPH PROJECTS ASIDE ═══════════════════════ -->
<section class="aside-section" id="graph-projects">
<div class="container">
<div class="version-header">
  <div class="version-name">Sidebar: The Graph Thread</div>
  <div class="version-date">2023–2025 · during the 13-month gap</div>
</div>

<p>Between BabyFoxAGI and BabyAGI 2, three standalone projects explored a parallel question: can LLMs build and maintain structured knowledge graphs? The ideas developed here — schema-driven extraction, plugin architectures, persistent graph storage — directly influenced BabyAGI 2's function registration system and BabyAGI 3's memory architecture.</p>

<div class="aside-grid">

<div class="aside-card">
  <div class="aside-card-title">Instagraph</div>
  <div class="aside-card-date">September 12, 2023</div>
  <p>Text in, knowledge graph out. A single API call to GPT-4 with a prompt asking it to identify entities and relationships, rendered with Cytoscape.js. No persistence, no schema, no deduplication — just <code>postData("/get_response_data", payload)</code> and a <code>cose</code> layout.</p>
  <p class="dim">The proof of concept: LLMs can extract structured graphs from unstructured text without custom NLP pipelines.</p>
</div>

<div class="aside-card">
  <div class="aside-card-title">MindGraph</div>
  <div class="aside-card-date">March 16, 2024</div>
  <p>A Flask app with a plugin integration system, schema-driven entity types, CRUD operations, and search. Uses OpenAI's function calling API with a <code>knowledge_graph</code> function definition to get structured extraction — entities, relationships, and source snippets — rather than hoping the LLM returns valid JSON.</p>
  <p class="dim">The integration manager pattern and schema-as-function-signature approach both reappear in BabyAGI 2's function registration and BabyAGI 3's tool system.</p>
</div>

<div class="aside-card">
  <div class="aside-card-title">Graphista</div>
  <div class="aside-card-date">February 15, 2025</div>
  <p>Full graph-based memory system. Two LLM loops: <code>ingest()</code> processes text through a SmartNodeProcessor (entity extraction, deduplication, graph updates via chain-of-thought) and <code>ask()</code> answers questions via SmartRetrievalTool with multi-step reasoning. Supports multiple backends (local JSON, Neo4j, FalkorDB), ontology-driven schemas, embeddings, and batch operations.</p>
  <p class="dim">The memory architecture that BabyAGI 3 absorbed: persistent graph storage, LLM-powered entity extraction, and embedding-based retrieval — all wrapped in a clean <code>Memory</code> class.</p>
</div>

</div>

<p class="dim">The progression from "ask the LLM once" (Instagraph) to "let the LLM manage a persistent graph through structured tool calls" (MindGraph → Graphista) traces the same arc as BabyAGI itself. The graph became the agent's memory layer — BabyAGI 3's SQLite-backed knowledge graph with entity extraction is the direct descendant of this work.</p>

</div>
</section>

<!-- ═══════════════════════════════════════════════════════════════ -->
<section class="version" id="v2">
<div class="version-header">
  <div class="version-name">BabyAGI 2</div>
  <div class="version-date">September 30, 2024</div>
</div>
<div class="version-loc">~5,960 lines · 40+ files · Python package <button class="source-btn" data-repo="yoheinakajima/babyagi" data-name="BabyAGI 2" data-branch="main">source ↗</button></div>

<p>BabyAGI 2 is a complete rewrite, informed by the graph experiments above. The concept shifts from "task list execution" to <strong>functions as first-class entities</strong>. The core abstraction is <code>Functionz</code> — a framework where every capability is a registered function with versioning, dependency resolution, logging, triggers, and a database backend. MindGraph's integration manager pattern reappears here as a general-purpose function registry.</p>

<div class="label">Architecture</div>
<div class="arch">
Functionz Framework
├── core/
│   ├── framework.py      ← Functionz class (entry point)
│   ├── registration.py   ← decorator + AST parameter parsing
│   └── execution.py      ← dependency resolution + exec()
├── db/
│   ├── base_db.py        ← abstract storage interface
│   ├── local_db.py       ← JSON file storage
│   ├── db_router.py      ← storage backend selector
│   └── models.py         ← data models
├── packs/
│   ├── default/          ← core functions (AI, OS, chat)
│   ├── drafts/           ← experimental (self_build, react_agent)
│   └── plugins/          ← integrations (airtable, firecrawl, payman...)
├── dashboard/            ← Flask web UI with function graph viz
└── api/                  ← REST API</div>

<div class="label">Function Registration</div>
<pre><code>@func.register_function(
    metadata={"description": "Search the web using SerpAPI"},
    imports=["serpapi"],
    key_dependencies=["SERPAPI_API_KEY"],
    triggers=["log_search_result"]
)
def search_web(query: str) -> dict:
    ...

<span class="diff-context"># Functions are stored in DB with full metadata:</span>
<span class="diff-context"># - versioned code (rollback support)</span>
<span class="diff-context"># - parsed input/output parameters via AST</span>
<span class="diff-context"># - dependency graph (auto-resolution at exec time)</span>
<span class="diff-context"># - triggers (functions that fire after execution)</span>
<span class="diff-context"># - execution logs with timing</span></code></pre>

<div class="label">Execution Engine</div>
<p>The executor resolves the full dependency graph at runtime: it loads function code from the database, <code>exec()</code>s it into a local scope, resolves imports (auto-installing missing packages via pip), injects secret keys, and wraps dependent functions so they're logged when called. Every execution is logged with parameters, output, timing, parent log ID, and trigger chain.</p>

<p>The <code>self_build</code> draft shows the ultimate goal: an LLM that can write, register, and execute its own functions. The <code>react_agent</code> draft implements a ReAct loop on top of Functionz.</p>

<div class="insight">BabyAGI 2 is not an agent — it's a <em>function runtime</em>. The insight is that agents are just functions that call other functions. By making functions first-class (with versioning, logging, triggers, and dependency resolution), you get agent behavior as an emergent property rather than a hardcoded loop.</div>
</section>

<!-- ═══════════════════════════════════════════════════════════════ -->
<section class="version" id="v2o">
<div class="version-header">
  <div class="version-name">BabyAGI 2o</div>
  <div class="version-date">October 17, 2024</div>
</div>
<div class="version-loc">174 lines · single file · Python <button class="source-btn" data-repo="yoheinakajima/babyagi-2o" data-name="BabyAGI 2o" data-branch="main">source ↗</button></div>

<p>BabyAGI 2o is a radical compression. The entire agent fits in 174 lines. It uses LiteLLM for model-agnostic inference and the native <strong>tool calling</strong> API. The agent starts with exactly three tools: <code>create_or_update_tool</code>, <code>install_package</code>, and <code>task_completed</code>.</p>

<div class="label">The Bootstrapping Loop</div>
<pre><code><span class="diff-context"># The agent builds its own tools. This is the entire system:</span>

tools = []  <span class="diff-context"># starts empty (plus 3 built-ins)</span>

def create_or_update_tool(name, code, description, parameters):
    exec(code, globals())
    register_tool(name, globals()[name], description, parameters)

<span class="diff-context"># Main loop: LLM calls tools, tools create more tools</span>
while iteration < max_iterations:
    response = completion(model=MODEL_NAME, messages=messages,
                          tools=tools, tool_choice="auto")
    for tool_call in response_message.tool_calls:
        result = call_tool(function_name, args)
    if 'task_completed' in tool_calls:
        break</code></pre>

<p>The system prompt tells the LLM to be self-sufficient: if information is needed, create a tool to find it. If a package is needed, install it. Auto-detect available API keys from environment variables. The LLM orchestrates everything through tool use — no explicit task list, no planner, no skill registry. Just a conversation with tool calls.</p>

<div class="insight">BabyAGI 2o proves that with modern tool-calling APIs, the minimal viable agent is remarkably small. The planning, execution, and tool creation from the classic versions all collapse into a single LLM conversation loop with <code>tool_choice="auto"</code>. The LLM <em>is</em> the planner.</div>

<div class="stats">
  <div class="stat"><div class="stat-value">174</div><div class="stat-label">total lines</div></div>
  <div class="stat"><div class="stat-value">3</div><div class="stat-label">built-in tools</div></div>
  <div class="stat"><div class="stat-value">50</div><div class="stat-label">max iterations</div></div>
  <div class="stat"><div class="stat-value">any</div><div class="stat-label">model (litellm)</div></div>
</div>
</section>

<!-- ═══════════════════════ PIPPIN SIDEBAR (hidden for now) ═══════════════════════
<section class="aside-section" id="pippin-projects">
<div class="container">
<div class="version-header">
  <div class="version-name">Sidebar: The Pippin Experiments</div>
  <div class="version-date">January 2025 · during the 16-month gap</div>
</div>

<p>Between BabyAGI 2o and v3, two experiments explored a different framing: what if an agent isn't a task executor but a <em>digital being</em> with personality, energy, mood, and autonomous behavior? The code introduced concepts that BabyAGI hadn't touched — and some that showed up in v3.</p>

<div class="aside-grid">

<div class="aside-card">
  <div class="aside-card-title">Pippin</div>
  <div class="aside-card-date">January 21, 2025</div>
  <p>A <code>DigitalBeing</code> framework (~5,200 lines) built around the concept of <em>activities</em> — autonomous behaviors selected by personality-weighted randomization, gated by energy costs and cooldowns. The agent has mood, energy that regenerates over time, and a character config that influences which activities it prefers. Activities range from tweeting to napping to suggesting new activities for itself. Uses a decorator pattern (<code>@activity(name=..., energy_cost=0.4, cooldown=259200)</code>) for registration, and a short-term/long-term memory consolidation system.</p>
  <p class="dim">The new idea: an agent that <em>initiates</em> its own behavior based on personality rather than waiting for user input. The activity selector, energy system, and Composio integration for third-party tools all prefigure BabyAGI 3's autonomous objectives and tool ecosystem.</p>
</div>

<div class="aside-card">
  <div class="aside-card-title">Pippin Lite</div>
  <div class="aside-card-date">January 22, 2025</div>
  <p>A 227-line single-file distillation. Same core pattern as BabyAGI 2o — a tool-calling loop with <code>create_or_update_tool</code> for self-extension — but with Composio tools auto-registered at startup and automatic API key detection from environment variables. Adds <code>task_completed()</code> as an explicit termination signal and <code>install_package()</code> for runtime dependency management.</p>
  <p class="dim">Essentially BabyAGI 2o plus Composio integration and better environment awareness. The auto-detection of available API keys and self-installing dependencies are small touches that reappear in v3's credential management.</p>
</div>

</div>

</div>
</section>
═══════════════════════════════════════════════════════════════ -->

<!-- ═══════════════════════════════════════════════════════════════ -->
<section class="version" id="v3">
<div class="version-header">
  <div class="version-name">BabyAGI 3</div>
  <div class="version-date">February 7, 2026</div>
</div>
<div class="version-loc">~33,500 lines · 70+ files · Python (async) <button class="source-btn" data-repo="yoheinakajima/babyagi3" data-name="BabyAGI 3" data-branch="main">source ↗</button></div>

<p>BabyAGI 3 is an autonomous assistant — not a task executor but a persistent agent that listens, remembers, and acts across channels. The core insight from the codebase docstring: <em>"Everything is still a message."</em> User input, tool execution, background objectives, scheduled tasks — all messages in conversation threads. The architecture extends the BabyAGI 2o pattern (LLM + tool loop) but adds every production concern: memory, multi-channel I/O, scheduling, budget tracking, context management, self-improvement, and error recovery.</p>

<div class="label">Architecture</div>
<div class="arch">
┌──────────────────────────────────────────────────────────────┐
│                         Agent                                 │
│                                                               │
│  Listeners (input)          Core Loop          Senders (out)  │
│  ┌─────────────┐    ┌──────────────────┐    ┌─────────────┐  │
│  │ CLI         │    │                  │    │ CLI         │  │
│  │ Email       │───►│  run_async()     │───►│ Email       │  │
│  │ SMS/iMsg    │    │  ┌────────────┐  │    │ SMS/iMsg    │  │
│  │ Voice       │    │  │ LLM Call   │  │    └─────────────┘  │
│  └─────────────┘    │  │  ▼         │  │                     │
│                     │  │ Tool Exec  │  │    ┌─────────────┐  │
│  ┌─────────────┐    │  │  ▼         │  │    │ Memory      │  │
│  │ Scheduler   │───►│  │ Loop until │  │───►│ (SQLite)    │  │
│  │ (cron/at/   │    │  │ end_turn   │  │    │ embeddings  │  │
│  │  interval)  │    │  └────────────┘  │    │ kg extract  │  │
│  └─────────────┘    └──────────────────┘    └─────────────┘  │
│                                                               │
│  ┌─────────────┐    ┌──────────────────┐    ┌─────────────┐  │
│  │ Objectives  │    │ Context Budget   │    │ Metrics     │  │
│  │ (bg tasks)  │    │ (trim/summarize) │    │ (cost/$)    │  │
│  │ priority Q  │    │ overflow recover │    │ per-model   │  │
│  │ retry+back  │    └──────────────────┘    └─────────────┘  │
│  │ cancel/budg │                                              │
│  └─────────────┘    ┌──────────────────┐                     │
│                     │ Tool Context     │                     │
│  ┌─────────────┐    │ (smart selection)│                     │
│  │ Credentials │    │ usage-weighted   │                     │
│  │ (keyring)   │    └──────────────────┘                     │
│  └─────────────┘                                              │
└──────────────────────────────────────────────────────────────┘</div>

<div class="label">Core Loop</div>
<p>The fundamental pattern is identical to 2o — an LLM message loop with tool calling — but wrapped in production infrastructure:</p>

<pre><code>async def run_async(self, user_input, thread_id="main", context=None):
    async with self._get_thread_lock(thread_id):
        thread = self.threads.setdefault(thread_id, [])
        self.repair_thread(thread_id)  <span class="diff-context"># fix orphaned tool_use</span>
        thread.append({"role": "user", "content": user_input})

        self._refresh_tool_selection(user_input, context)

        while True:
            <span class="diff-context"># Trim thread to fit context window</span>
            thread = self._context_budget.trim_thread(thread, ...)

            <span class="diff-context"># LLM call with 3-stage overflow recovery</span>
            try:
                response = await self.client.messages.create(...)
            except ContextOverflow:
                <span class="diff-context"># Stage 1: aggressive trim</span>
                <span class="diff-context"># Stage 2: minimal thread + core tools</span>
                <span class="diff-context"># Stage 3: clear thread, inform user</span>

            if response.stop_reason == "end_turn":
                return self._extract_text(response)

            <span class="diff-context"># Execute tools (async in thread pool)</span>
            for block in response.content:
                if block.type == "tool_use":
                    result = await asyncio.to_thread(
                        self.tools[block.name].execute, ...)
                    <span class="diff-context"># Large results → LLM summarization</span></code></pre>

<div class="label">Objectives System</div>
<p>Background objectives run as separate agent loops in their own conversation threads with full concurrency control:</p>

<pre><code>@dataclass
class Objective:
    id: str
    goal: str
    status: str       <span class="diff-context"># pending → running → completed/failed/cancelled</span>
    priority: int     <span class="diff-context"># 1-10, lower = higher</span>
    budget_usd: float <span class="diff-context"># cost cap (None = unlimited)</span>
    token_limit: int  <span class="diff-context"># token cap</span>
    retry_count: int  <span class="diff-context"># auto-retry with exponential backoff</span>
    error_history: list  <span class="diff-context"># fed to retries for adaptive strategy</span></code></pre>

<p>Max 5 concurrent objectives via semaphore. Failed objectives retry with exponential backoff (2s, 4s, 8s). Each retry receives the full error history so the LLM can adapt its approach. Budget/token limits halt execution when exceeded.</p>

<div class="label">Memory</div>
<p>SQLite-backed persistent memory with event logging, entity extraction, knowledge graph, embeddings search, and context assembly — the direct descendant of the Instagraph → MindGraph → Graphista line. Memory is assembled into the system prompt dynamically. The <code>ToolContextBuilder</code> selects which tools to include in each API call based on query relevance, usage patterns, and current channel.</p>

<div class="label">Self-Improvement</div>
<p>Tools created at runtime via <code>register_tool</code> are persisted to the database and reloaded on startup. Three tool types: executable (Python code), skill (behavioral instructions), and composio (third-party wrappers). External packages detected via AST analysis are sandboxed in e2b. Tools track execution statistics for monitoring.</p>

<div class="label">Multi-Channel</div>
<p>The listener/sender architecture decouples I/O. Each message carries context: <code>channel</code>, <code>is_owner</code>, <code>sender</code>. The system prompt adapts — iMessage gets terse responses with no markdown; emails get structured prose; external contacts get privacy-respecting replies. Owner vs. non-owner access controls are enforced at the prompt level.</p>

<div class="label">Resilience</div>
<p>Thread repair fixes orphaned <code>tool_use</code> blocks (a common crash mode). 3-stage context overflow recovery. Per-thread locks prevent race conditions between concurrent sources. Large tool results are summarized by a fast model before entering the context. Graceful fallbacks at every layer — broken tools are disabled rather than crashing startup.</p>

<div class="insight">BabyAGI 3 is the synthesis — and the shift from agent to autonomous assistant. The 2o insight (LLM is the planner) becomes the core loop. The classic-era skills become persisted tools. The Fox-era reflection becomes structured memory. The Pippin-era personality becomes channel-aware behavior. The v2 function runtime becomes the tool registration system. And the whole thing is wrapped in the engineering that turns a prototype into something you can actually leave running: async, concurrency control, budget limits, error recovery, multi-channel I/O, and context window management.</div>

<div class="stats">
  <div class="stat"><div class="stat-value">~33.5k</div><div class="stat-label">lines</div></div>
  <div class="stat"><div class="stat-value">async</div><div class="stat-label">runtime</div></div>
  <div class="stat"><div class="stat-value">5</div><div class="stat-label">max concurrent</div></div>
  <div class="stat"><div class="stat-value">SQLite</div><div class="stat-label">memory</div></div>
</div>
</section>

<!-- ═══════════════════════════════════════════════════════════════ -->
<section class="version" id="evolution">
<div class="version-header">
  <div class="version-name">Evolution</div>
  <div class="version-date">2023–2026</div>
</div>

<div class="label">Lines of Code</div>
<div class="arch">
BabyAGI     ████                                           105
BabyBeeAGI  █████████                                      300
BabyCatAGI  ██████████                                     320
BabyDeerAGI ███████████                                    354
BabyElfAGI  ███████████████████████████                    887
BabyFoxAGI  ██████████████████████████████████████████    2,299
BabyAGI 2o  █████                                          174
BabyAGI 2   ████████████████████████████████████████████  5,962
BabyAGI 3   █████████████████████████████████████████████33,506</div>

<div class="label">Capability Heatmap <span class="scroll-hint">scroll →</span></div>
<p class="dim">Each cell shows when a capability appeared and how sophisticated it became. Darker = more advanced implementation.</p>

<div class="heatmap-wrap">
<div class="heatmap">
  <div class="heatmap-header"></div>
  <div class="heatmap-header">v1</div>
  <div class="heatmap-header">Bee</div>
  <div class="heatmap-header">Cat</div>
  <div class="heatmap-header">Deer</div>
  <div class="heatmap-header">Elf</div>
  <div class="heatmap-header">Fox</div>
  <div class="heatmap-header">v2</div>
  <div class="heatmap-header">2o</div>
  <div class="heatmap-header">v3</div>

  <div class="heatmap-row-label">Planning</div>
  <div class="heatmap-cell l2">loop</div>
  <div class="heatmap-cell l3">dynamic</div>
  <div class="heatmap-cell l3">upfront</div>
  <div class="heatmap-cell l3">upfront</div>
  <div class="heatmap-cell l4">+reflect</div>
  <div class="heatmap-cell l4">+reflect</div>
  <div class="heatmap-cell l0">—</div>
  <div class="heatmap-cell l5">implicit</div>
  <div class="heatmap-cell l5">implicit</div>

  <div class="heatmap-row-label">Tools</div>
  <div class="heatmap-cell l0">0</div>
  <div class="heatmap-cell l2">3</div>
  <div class="heatmap-cell l2">3</div>
  <div class="heatmap-cell l2">4</div>
  <div class="heatmap-cell l3">7</div>
  <div class="heatmap-cell l4">15+</div>
  <div class="heatmap-cell l4">packs</div>
  <div class="heatmap-cell l5">self</div>
  <div class="heatmap-cell l6">self+DB</div>

  <div class="heatmap-row-label">Memory</div>
  <div class="heatmap-cell l2">vec DB</div>
  <div class="heatmap-cell l1">string</div>
  <div class="heatmap-cell l2">deps</div>
  <div class="heatmap-cell l2">deps</div>
  <div class="heatmap-cell l3">embed</div>
  <div class="heatmap-cell l4">cache</div>
  <div class="heatmap-cell l3">logs</div>
  <div class="heatmap-cell l1">msgs</div>
  <div class="heatmap-cell l6">SQLite+KG</div>

  <div class="heatmap-row-label">Concurrency</div>
  <div class="heatmap-cell l0">—</div>
  <div class="heatmap-cell l0">—</div>
  <div class="heatmap-cell l0">—</div>
  <div class="heatmap-cell l3">threads</div>
  <div class="heatmap-cell l3">threads</div>
  <div class="heatmap-cell l3">threads</div>
  <div class="heatmap-cell l0">—</div>
  <div class="heatmap-cell l0">—</div>
  <div class="heatmap-cell l6">async</div>

  <div class="heatmap-row-label">Error recovery</div>
  <div class="heatmap-cell l0">—</div>
  <div class="heatmap-cell l1">basic</div>
  <div class="heatmap-cell l1">basic</div>
  <div class="heatmap-cell l1">basic</div>
  <div class="heatmap-cell l1">basic</div>
  <div class="heatmap-cell l1">basic</div>
  <div class="heatmap-cell l2">logged</div>
  <div class="heatmap-cell l1">basic</div>
  <div class="heatmap-cell l6">retry+repair</div>

  <div class="heatmap-row-label">I/O channels</div>
  <div class="heatmap-cell l1">CLI</div>
  <div class="heatmap-cell l1">CLI</div>
  <div class="heatmap-cell l1">CLI</div>
  <div class="heatmap-cell l2">CLI+file</div>
  <div class="heatmap-cell l2">CLI+file</div>
  <div class="heatmap-cell l4">web UI</div>
  <div class="heatmap-cell l3">dash</div>
  <div class="heatmap-cell l1">CLI</div>
  <div class="heatmap-cell l6">multi</div>

  <div class="heatmap-row-label">Self-improve</div>
  <div class="heatmap-cell l0">—</div>
  <div class="heatmap-cell l0">—</div>
  <div class="heatmap-cell l0">—</div>
  <div class="heatmap-cell l0">—</div>
  <div class="heatmap-cell l2">detect</div>
  <div class="heatmap-cell l3">reflect</div>
  <div class="heatmap-cell l4">version</div>
  <div class="heatmap-cell l5">exec()</div>
  <div class="heatmap-cell l6">persist</div>

  <div class="heatmap-row-label">Model lock-in</div>
  <div class="heatmap-cell l5">hard</div>
  <div class="heatmap-cell l5">hard</div>
  <div class="heatmap-cell l4">mixed</div>
  <div class="heatmap-cell l4">mixed</div>
  <div class="heatmap-cell l4">mixed</div>
  <div class="heatmap-cell l4">mixed</div>
  <div class="heatmap-cell l1">any</div>
  <div class="heatmap-cell l1">any</div>
  <div class="heatmap-cell l1">any</div>
</div>
</div>

<div class="label">Where the Code Goes (BabyAGI 3)</div>
<p class="dim">Approximate breakdown of ~33.5k lines by function. The production concerns dwarf the actual agent logic — the core loop that decides what to do next is under 200 lines.</p>

<div class="anatomy-chart">
  <div class="anatomy-row">
    <div class="anatomy-label">Core loop</div>
    <div class="anatomy-bar-wrap">
      <div class="anatomy-segment seg-core" style="width: 1.5%;" title="Core agent loop: ~500 lines"></div>
    </div>
    <div class="anatomy-total">~500</div>
  </div>
  <div class="anatomy-row">
    <div class="anatomy-label">Tools</div>
    <div class="anatomy-bar-wrap">
      <div class="anatomy-segment seg-tools" style="width: 30%;" title="Tool definitions and registration: ~10,000 lines"></div>
    </div>
    <div class="anatomy-total">~10,000</div>
  </div>
  <div class="anatomy-row">
    <div class="anatomy-label">Memory</div>
    <div class="anatomy-bar-wrap">
      <div class="anatomy-segment seg-memory" style="width: 15%;" title="SQLite, embeddings, knowledge graph: ~5,000 lines"></div>
    </div>
    <div class="anatomy-total">~5,000</div>
  </div>
  <div class="anatomy-row">
    <div class="anatomy-label">I/O + channels</div>
    <div class="anatomy-bar-wrap">
      <div class="anatomy-segment seg-io" style="width: 20%;" title="Listeners, senders, formatting: ~6,500 lines"></div>
    </div>
    <div class="anatomy-total">~6,500</div>
  </div>
  <div class="anatomy-row">
    <div class="anatomy-label">Infrastructure</div>
    <div class="anatomy-bar-wrap">
      <div class="anatomy-segment seg-infra" style="width: 34%;" title="Context mgmt, scheduling, credentials, metrics, error handling: ~11,500 lines"></div>
    </div>
    <div class="anatomy-total">~11,500</div>
  </div>
  <div class="anatomy-legend">
    <div class="anatomy-legend-item"><div class="anatomy-legend-swatch seg-core"></div>Core loop</div>
    <div class="anatomy-legend-item"><div class="anatomy-legend-swatch seg-tools"></div>Tools + registry</div>
    <div class="anatomy-legend-item"><div class="anatomy-legend-swatch seg-memory"></div>Memory</div>
    <div class="anatomy-legend-item"><div class="anatomy-legend-swatch seg-io"></div>I/O channels</div>
    <div class="anatomy-legend-item"><div class="anatomy-legend-swatch seg-infra"></div>Infrastructure</div>
  </div>
</div>

<div class="label">Architectural Transitions</div>

<div class="transitions-list">

<div class="transition-item">
  <div class="transition-label">Task mgmt</div>
  <div class="transition-stages">
    <span class="stage">Infinite loop</span><span class="arrow">›</span>
    <span class="stage">finite task list</span><span class="arrow">›</span>
    <span class="stage">upfront planning</span><span class="arrow">›</span>
    <span class="stage">parallel DAG</span><span class="arrow">›</span>
    <span class="stage">skill + reflection</span><span class="arrow">›</span>
    <span class="stage"><strong>LLM-native tool loop</strong></span>
  </div>
</div>

<div class="transition-item">
  <div class="transition-label">Extensibility</div>
  <div class="transition-stages">
    <span class="stage">Hardcoded tools</span><span class="arrow">›</span>
    <span class="stage">skill base class</span><span class="arrow">›</span>
    <span class="stage">dynamic discovery</span><span class="arrow">›</span>
    <span class="stage">reflection</span><span class="arrow">›</span>
    <span class="stage">fn runtime + versioning</span><span class="arrow">›</span>
    <span class="stage"><strong>self-extending + persistent</strong></span>
  </div>
</div>

<div class="transition-item">
  <div class="transition-label">Memory</div>
  <div class="transition-stages">
    <span class="stage">Pinecone embeddings</span><span class="arrow">›</span>
    <span class="stage">session string</span><span class="arrow">›</span>
    <span class="stage">dep-chain context</span><span class="arrow">›</span>
    <span class="stage">few-shot matching</span><span class="arrow">›</span>
    <span class="stage">forever cache + summary</span><span class="arrow">›</span>
    <span class="stage">exec logs</span><span class="arrow">›</span>
    <span class="stage"><strong>SQLite + knowledge graph</strong></span>
  </div>
</div>

<div class="transition-item">
  <div class="transition-label">Execution</div>
  <div class="transition-stages">
    <span class="stage">Sequential</span><span class="arrow">›</span>
    <span class="stage">threaded parallel</span><span class="arrow">›</span>
    <span class="stage">synchronous fns</span><span class="arrow">›</span>
    <span class="stage"><strong>async + semaphore + thread pool</strong></span>
  </div>
</div>

<div class="transition-item">
  <div class="transition-label">I/O</div>
  <div class="transition-stages">
    <span class="stage">CLI print</span><span class="arrow">›</span>
    <span class="stage">CLI + file</span><span class="arrow">›</span>
    <span class="stage">Flask web UI</span><span class="arrow">›</span>
    <span class="stage">CLI + dashboard</span><span class="arrow">›</span>
    <span class="stage"><strong>multi-channel + access control</strong></span>
  </div>
</div>

</div>

<div class="label">Lessons</div>

<p class="dim">The codebase progression reveals several non-obvious lessons for agent builders:</p>

<div class="lessons-grid">

<div class="lesson-card" data-num="01">
  <div class="lesson-body"><span class="lesson-title">A few hundred lines is a powerful benchmark.</span> <p>The original BabyAGI proved that 105 lines could produce emergent multi-step behavior. BabyAGI 2o later showed that even with tool calling and self-extension, the core agent fits in a few hundred lines. Everything beyond that is production concerns — the same concerns that dominate any real system.</p></div>
</div>

<div class="lesson-card" data-num="02">
  <div class="lesson-body"><span class="lesson-title">Task management gets layered, not eliminated.</span> <p>The classic-era task list wasn't wrong — it was too simple. Long-running objectives shouldn't block chat. Background tasks need their own threads, budgets, and retry logic. BabyAGI 3's objectives system is far more sophisticated than a list, but the core idea of structured task tracking persists.</p></div>
</div>

<div class="lesson-card" data-num="03">
  <div class="lesson-body"><span class="lesson-title">Self-improvement needs persistence.</span> <p>BabyFoxAGI's <code>reflect_skills()</code> identified missing skills but couldn't act on it. BabyAGI 2 stored improvements but lacked the runtime. BabyAGI 3 closes the loop: create tool → persist to DB → reload on startup.</p></div>
</div>

<div class="lesson-card" data-num="04">
  <div class="lesson-body"><span class="lesson-title">Context management dwarfs agent logic.</span> <p>BabyAGI 3 dedicates more code to context budgeting, thread trimming, tool result summarization, and overflow recovery than to its actual agent logic. Infrastructure is ~11,500 lines; the core loop is ~500.</p></div>
</div>

<div class="lesson-card" data-num="05">
  <div class="lesson-body"><span class="lesson-title">Graphs beat flat memory.</span> <p>The parallel Instagraph → MindGraph → Graphista line proved that LLMs can maintain structured knowledge graphs through tool calls. BabyAGI 3's memory absorbed this: entity extraction, knowledge graph queries, and embedding search — not just a rolling summary.</p></div>
</div>

</div>

</section>

<!-- ═══════════════════════════ TIMELINE ═══════════════════════════ -->
<section class="version" id="timeline">
<div class="version-header">
  <div class="version-name">Timeline</div>
  <div class="version-date">BabyAGI in context</div>
</div>

<p>BabyAGI didn't evolve in isolation. The timeline below maps each version against the industry milestones that shaped it — organized by the concepts that matter to agent builders rather than by calendar. <span class="scroll-hint">scroll →</span></p>

</div><!-- close container for full-width timeline -->

<div class="comparison-wrap">
<table class="comparison-table" style="min-width: 880px;">
<thead>
<tr>
  <th></th>
  <th>Q1 '23</th>
  <th>Q2 '23</th>
  <th>Q3 '23</th>
  <th>Q4 '23</th>
  <th>Q1 '24</th>
  <th>Q2 '24</th>
  <th>Q3 '24</th>
  <th>Q4 '24</th>
  <th>Q1 '25</th>
  <th>Q1 '26</th>
</tr>
</thead>
<tbody>
<tr>
  <td>BabyAGI</td>
  <td class="highlight">v1</td>
  <td class="highlight">Bee · Cat · Deer</td>
  <td class="highlight">Elf · Fox</td>
  <td></td>
  <td></td>
  <td></td>
  <td class="highlight">v2</td>
  <td class="highlight">2o</td>
  <td></td>
  <td class="highlight">v3</td>
</tr>
<tr style="border-bottom: 1px solid var(--border);">
  <td>Models</td>
  <td class="highlight">GPT-4</td>
  <td>GPT-3.5 16k</td>
  <td></td>
  <td>GPT-4 Turbo</td>
  <td></td>
  <td>GPT-4o · Claude 3.5 Sonnet</td>
  <td>o1</td>
  <td></td>
  <td>DeepSeek R1</td>
  <td></td>
</tr>
<tr>
  <td>Tool calling</td>
  <td></td>
  <td class="highlight">fn calling API</td>
  <td></td>
  <td>Assistants API</td>
  <td></td>
  <td>Claude tool use</td>
  <td></td>
  <td class="highlight">MCP</td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>Structured output</td>
  <td></td>
  <td></td>
  <td></td>
  <td>JSON mode</td>
  <td></td>
  <td></td>
  <td class="highlight">Structured Outputs</td>
  <td></td>
  <td></td>
  <td></td>
</tr>
<tr>
  <td>Agent frameworks</td>
  <td class="highlight">AutoGPT</td>
  <td>LangChain agents</td>
  <td></td>
  <td></td>
  <td>CrewAI</td>
  <td>LangGraph</td>
  <td></td>
  <td>AutoGen + SK merge</td>
  <td>OpenAI Agents SDK</td>
  <td>OpenClaw</td>
</tr>
<tr>
  <td>Graph projects</td>
  <td></td>
  <td></td>
  <td class="highlight">Instagraph</td>
  <td></td>
  <td style="font-style: italic; color: var(--text-dim);">MindGraph</td>
  <td>GraphRAG</td>
  <td></td>
  <td></td>
  <td style="font-style: italic; color: var(--text-dim);">Graphista</td>
  <td></td>
</tr>
<tr style="border-top: 1px solid var(--border-light);">
  <td>BabyAGI insight</td>
  <td></td>
  <td style="font-style: italic; color: var(--text-dim);">LLMs can chain tasks · plan upfront · parallelize</td>
  <td style="font-style: italic; color: var(--text-dim);">plugin arch · reflect</td>
  <td></td>
  <td></td>
  <td></td>
  <td style="font-style: italic; color: var(--text-dim);">fns as atoms</td>
  <td style="font-style: italic; color: var(--text-dim);">LLM is planner</td>
  <td></td>
  <td style="font-style: italic; color: var(--text-dim);">autonomous assistant</td>
</tr>
</tbody>
</table>
</div>

<div class="container">

<div class="label" style="margin-top: 1.5rem;">How the concepts connect</div>

<p>The evolution of tool calling directly shaped BabyAGI's architecture. The classic era (v1–Fox) predated OpenAI's function calling API — every version had to invent its own mechanism for getting an LLM to choose and invoke tools, typically via fragile JSON parsing from chat completions. When function calling launched in June '23, it validated BabyFoxAGI's approach (which had landed days earlier using the same pattern). But it also made the explicit task list unnecessary: if the model can natively call functions, why maintain a separate planner?</p>

<p>That insight took 13 months to crystallize. The gap between Fox (Sep '23) and v2 (Sep '24) spans the arrival of the Assistants API, Claude tool use, GPT-4o, CrewAI, LangGraph, and structured outputs — a complete rewiring of the agent infrastructure stack. When BabyAGI returned, it had absorbed all of it: v2 replaced the task list with a function runtime, and 2o compressed the entire agent to 174 lines by delegating planning to native tool calling.</p>

<p>The second gap (Oct '24 → Feb '26) coincided with MCP and the OpenAI Agents SDK — the industry's shift from "how do agents call tools" to "how do agents interoperate." BabyAGI 3 reflects this: multi-channel I/O, standardized tool registration, and the production infrastructure (context management, budgeting, error recovery) that none of the earlier versions or frameworks addressed.</p>

<p>Structured outputs (Aug '24) are the quiet revolution in this timeline. Before them, every agent framework spent significant code parsing LLM responses into actionable data — BabyAGI's classic era is littered with <code>json.loads()</code> wrapped in try/except. Structured outputs eliminated that entire class of failure, and BabyAGI 2o's radical simplicity (174 lines) is partly possible because it doesn't need response parsing infrastructure.</p>

</section>

</div>
</main>

<!-- ═══════════════════════ IMPACT ═══════════════════════ -->
<section class="impact-section">
<div class="container">

<div class="version-header">
  <div class="version-name">Impact</div>
</div>

<p>BabyAGI's influence is less about the code itself — most of it was intentionally disposable — and more about what it demonstrated at each stage. The original 105-line script, released days after GPT-4, showed tens of thousands of developers that autonomous agents were within reach. Each subsequent version served as a public experiment in a different architectural bet.</p>

<div class="accent-line"></div>

<p>The original release — alongside AutoGPT, which launched the same week — kicked off the first wave of agent experimentation. CrewAI, Lovable, and dozens of others followed within the year, each exploring variations on the same core pattern. BabyAGI's contribution was proving its simplicity: a while loop, an LLM call, and a task queue is all you need to get emergent multi-step behavior.</p>

<p>The later versions mattered differently. BabyAGI 2 introduced the idea of functions as first-class entities with versioning and dependency resolution — a pattern that influenced how developers thought about composable agent capabilities. BabyAGI 2o's compression to 174 lines showed that as LLMs improved, most agent scaffolding became unnecessary — the model itself could plan. And BabyAGI 3's expansion to 33,000 lines showed the opposite truth: building an autonomous assistant isn't hard because of the AI, it's hard because of everything else — context window limits, concurrent execution, multi-channel I/O, error recovery, cost control, and the thousand small decisions about what to do when things go wrong.</p>

<p>Together, the nine versions form a public record of one person learning, in real time, what it actually takes to build an agent that works.</p>

</div>
</section>

<footer>
<div class="container">
  <div class="accent-line"></div>
  Analysis based on source code from github.com/yoheinakajima.<br>
  Generated February 2026.
</div>
</footer>

<!-- Source code modal -->
<div class="source-overlay" id="sourceOverlay">
  <div class="source-modal">
    <div class="source-modal-header">
      <div class="source-modal-left">
        <span class="source-modal-title" id="sourceTitle"></span>
        <a class="source-modal-link" id="sourceLink" href="#" target="_blank" rel="noopener">github ↗</a>
      </div>
      <button class="source-modal-close" id="sourceClose" aria-label="Close">&#x2715;</button>
    </div>
    <div class="source-modal-body">
      <div class="source-tree" id="sourceTree">
        <div class="source-loading"><span class="source-loading-dots">loading...</span></div>
      </div>
      <div class="source-code-wrap">
        <div class="source-code-path" id="sourceCodePath">&nbsp;</div>
        <div class="source-code" id="sourceCode">
          <div class="source-placeholder">select a file to view</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
(function() {
  /* ── Navigation scroll tracking ── */
  const navLinks = document.querySelectorAll('nav a[href^="#"]');
  const sections = [];
  navLinks.forEach(link => {
    const id = link.getAttribute('href').slice(1);
    const el = document.getElementById(id);
    if (el) sections.push({ el, link });
  });
  /* ── Center active nav item in scroll container ── */
  const navContainer = document.querySelector('nav .container');
  function centerActiveNav(link) {
    if (!navContainer) return;
    const scrollLeft = link.offsetLeft - navContainer.offsetWidth / 2 + link.offsetWidth / 2;
    navContainer.scrollTo({ left: scrollLeft, behavior: 'smooth' });
  }

  const observer = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      const match = sections.find(s => s.el === entry.target);
      if (match && entry.isIntersecting) {
        navLinks.forEach(l => l.classList.remove('active'));
        match.link.classList.add('active');
        centerActiveNav(match.link);
      }
    });
  }, { rootMargin: '-40% 0px -55% 0px' });
  sections.forEach(s => observer.observe(s.el));

  /* Center nav item immediately on tap */
  navLinks.forEach(link => {
    link.addEventListener('click', () => centerActiveNav(link));
  });

  /* ── Source code modal ── */
  var treeCache = {};
  var fileCache = {};
  var overlay = document.getElementById('sourceOverlay');
  var titleEl = document.getElementById('sourceTitle');
  var linkEl = document.getElementById('sourceLink');
  var treeEl = document.getElementById('sourceTree');
  var codeEl = document.getElementById('sourceCode');
  var pathEl = document.getElementById('sourceCodePath');
  var closeBtn = document.getElementById('sourceClose');

  function escapeHtml(s) {
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  }

  function isBinary(path) {
    var exts = ['.png','.jpg','.jpeg','.gif','.ico','.bmp','.webp',
      '.woff','.woff2','.ttf','.eot','.otf',
      '.mp3','.mp4','.wav','.ogg','.webm','.avi',
      '.zip','.gz','.tar','.bz2','.7z','.rar',
      '.pdf','.pyc','.pyd','.exe','.dll','.so','.o',
      '.db','.sqlite','.sqlite3','.pkl','.pickle',
      '.DS_Store','.class','.jar'];
    var dot = path.lastIndexOf('.');
    if (dot === -1) return false;
    return exts.indexOf(path.substring(dot).toLowerCase()) !== -1;
  }

  function openModal(repo, name, branch) {
    titleEl.textContent = name;
    linkEl.href = 'https://github.com/' + repo;
    if (branch && branch !== 'main' && branch !== 'master') {
      linkEl.href = 'https://github.com/' + repo + '/tree/' + branch;
    }
    treeEl.innerHTML = '<div class="source-loading"><span class="source-loading-dots">loading\u2026</span></div>';
    codeEl.innerHTML = '<div class="source-placeholder">select a file to view</div>';
    pathEl.innerHTML = '&nbsp;';
    overlay.classList.add('active');
    document.body.style.overflow = 'hidden';
    fetchTree(repo, branch);
  }

  function closeModal() {
    overlay.classList.remove('active');
    document.body.style.overflow = '';
  }

  closeBtn.addEventListener('click', closeModal);
  overlay.addEventListener('click', function(e) {
    if (e.target === overlay) closeModal();
  });
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && overlay.classList.contains('active')) closeModal();
  });

  function fetchTree(repo, branch) {
    var cacheKey = repo + '/' + branch;
    if (treeCache[cacheKey]) {
      renderTree(treeCache[cacheKey], repo, treeCache[cacheKey]._branch);
      return;
    }

    var branches = [branch || 'main', 'master'];
    // Remove duplicates
    if (branches[0] === branches[1]) branches = [branches[0]];

    tryBranch(repo, branches, 0, cacheKey);
  }

  function tryBranch(repo, branches, idx, cacheKey) {
    if (idx >= branches.length) {
      treeEl.innerHTML = '<div class="source-loading">could not load repository</div>';
      return;
    }
    var br = branches[idx];
    var url = 'https://api.github.com/repos/' + repo + '/git/trees/' + br + '?recursive=1';
    fetch(url).then(function(res) {
      if (!res.ok) throw new Error(res.status);
      return res.json();
    }).then(function(data) {
      var result = { items: data.tree || [], _branch: br };
      treeCache[cacheKey] = result;
      renderTree(result, repo, br);
    }).catch(function() {
      tryBranch(repo, branches, idx + 1, cacheKey);
    });
  }

  function buildTree(items) {
    var root = {};
    items.forEach(function(item) {
      if (item.type !== 'blob') return;
      var parts = item.path.split('/');
      var cur = root;
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (i === parts.length - 1) {
          cur[p] = { _file: true, path: item.path, size: item.size || 0 };
        } else {
          if (!cur[p] || cur[p]._file) cur[p] = {};
          cur = cur[p];
        }
      }
    });
    return root;
  }

  function renderTree(data, repo, branch) {
    var tree = buildTree(data.items);
    treeEl.innerHTML = '';
    renderNode(tree, treeEl, repo, branch, 0);
  }

  function renderNode(node, parent, repo, branch, depth) {
    var entries = Object.keys(node).sort(function(a, b) {
      var aDir = node[a] && !node[a]._file;
      var bDir = node[b] && !node[b]._file;
      if (aDir && !bDir) return -1;
      if (!aDir && bDir) return 1;
      return a.toLowerCase().localeCompare(b.toLowerCase());
    });

    entries.forEach(function(name) {
      var val = node[name];
      var isFile = val && val._file;
      var btn = document.createElement('button');
      btn.className = 'source-tree-item';
      btn.style.paddingLeft = (0.8 + depth * 0.75) + 'rem';

      if (isFile) {
        btn.textContent = name;
        btn.addEventListener('click', function() {
          var prev = treeEl.querySelector('.source-tree-item.active');
          if (prev) prev.classList.remove('active');
          btn.classList.add('active');
          loadFile(repo, branch, val.path);
        });
        parent.appendChild(btn);
      } else {
        btn.className += ' is-folder open';
        btn.innerHTML = '<span class="folder-arrow">\u25B8</span> ' + escapeHtml(name);
        var container = document.createElement('div');
        btn.addEventListener('click', function() {
          var isOpen = btn.classList.contains('open');
          btn.classList.toggle('open');
          btn.classList.toggle('closed');
          container.style.display = isOpen ? 'none' : '';
        });
        parent.appendChild(btn);
        renderNode(val, container, repo, branch, depth + 1);
        parent.appendChild(container);
      }
    });
  }

  function loadFile(repo, branch, path) {
    pathEl.textContent = path;
    if (isBinary(path)) {
      codeEl.innerHTML = '<div class="source-placeholder">binary file \u2014 <a href="https://github.com/' +
        repo + '/blob/' + branch + '/' + path + '" target="_blank" rel="noopener" style="color:var(--text-dim);border-bottom:1px solid var(--border)">view on GitHub</a></div>';
      return;
    }

    var key = repo + '/' + branch + '/' + path;
    if (fileCache[key]) {
      renderCode(fileCache[key]);
      return;
    }

    codeEl.innerHTML = '<div class="source-loading"><span class="source-loading-dots">loading\u2026</span></div>';
    var url = 'https://raw.githubusercontent.com/' + repo + '/' + branch + '/' + encodeURIComponent(path).replace(/%2F/g, '/');
    fetch(url).then(function(res) {
      if (!res.ok) throw new Error(res.status);
      return res.text();
    }).then(function(text) {
      // Truncate very large files
      if (text.length > 500000) {
        text = text.substring(0, 500000) + '\n\n... (truncated — file too large, view full file on GitHub)';
      }
      fileCache[key] = text;
      renderCode(text);
    }).catch(function() {
      codeEl.innerHTML = '<div class="source-placeholder">could not load file</div>';
    });
  }

  function renderCode(text) {
    var lines = text.split('\n');
    var html = [];
    for (var i = 0; i < lines.length; i++) {
      html.push('<div class="source-line"><span class="source-line-num">' + (i + 1) +
        '</span><span class="source-line-content">' + escapeHtml(lines[i]) + '</span></div>');
    }
    codeEl.innerHTML = '<div class="source-code-inner">' + html.join('') + '</div>';
    codeEl.scrollTop = 0;
  }

  /* ── Button handlers ── */
  document.querySelectorAll('.source-btn').forEach(function(btn) {
    btn.addEventListener('click', function(e) {
      e.preventDefault();
      openModal(btn.dataset.repo, btn.dataset.name, btn.dataset.branch);
    });
  });
})();
</script>

</body>
</html>